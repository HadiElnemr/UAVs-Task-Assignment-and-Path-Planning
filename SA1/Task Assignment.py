# -*- coding: utf-8 -*-
"""Copy of Optimisation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SONG9XAco5d1-gTb-WfuBxl0E8Ayf_8j
"""

import math
import random
import copy
from matplotlib import pyplot as plt

class Point:
  def __init__(self, x, y):
    self.x = x
    self.y = y
  
  def add_shift(self, e_x, e_y):
    # add noise shift (+ve or -ve). ex: e_x = 0.5  x = (1 + 0.5) * x
    self.x += e_x
    self.y += e_y

  def __str__(self):
    return f"x: {self.x}, y: {self.y}"

  def __repr__(self):
    return f"x: {self.x}, y: {self.y}"
  

def rand_position(x_max, y_max):
  return Point(x_max*random.random(), y_max*random.random())
  
rand_position(2,2)

class Task:
  def __init__(self, position):
    self.position=position

class UAV:
  def __init__(self, position=None, list_of_tasks=None, path=None):
    if list_of_tasks is None:
      list_of_tasks = []
    if path is None:
      path = []
    self.path = path
    self.list_of_tasks = list_of_tasks
    self.position = position
    self.max_tasks = 3

  def number_of_assigned_tasks(self):
    return len(self.list_of_tasks)
  
  def distance_of_UAV(self):
    sum=0
    if self.number_of_assigned_tasks() > 0:
      sum=get_distance(self.position,self.list_of_tasks[0].position)
      
      for i in range(1,self.number_of_assigned_tasks()):
        sum=sum+get_distance(self.list_of_tasks[i-1].position,self.list_of_tasks[i].position)
    
    return sum
  
  def path_length(self):
    length = 0
    if self.number_of_assigned_tasks() > 0:
      length = get_distance(self.position, self.path[0])
      
      for i in range(len(self.path)-1):
        length = length + get_distance(self.path[i], self.path[i+1])
    
    return sum

  def __str__(self):
    st=""
    for task in self.list_of_tasks:
      st += "("+str(task.position.x) + ","+str(task.position.y)+") "
    return f"Position {self.position} \nTasks : {st}"
    
  def __repr__(self):
     st=""
     for task in self.list_of_tasks:
      st += "("+str(task.position.x) + ","+str(task.position.y)+") "
     return f"Position {self.position} \n Tasks : {st}"
    
    # def show(self):
    #   for task in self.list_of_tasks:
    #     st += task.position.__str__() + " - "  
    #   print(f"Position: {self.position} \n Tasks : {st}")

def get_distance(p1, p2):
  return math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2)

class System:
  def __init__(self, list_of_UAVs ,list_of_tasks):

    self.list_of_UAVs = list_of_UAVs
    self.list_of_tasks = list_of_tasks
    self.Weight=3
    assign_tasks(list_of_tasks,list_of_UAVs)
    
    self.best_Obj=self.cost()
    self.candidate=[]
    self.candidate_Obj= None
  
  def cost(self):
    sum=0
    for x in self.list_of_UAVs:
      sum=sum+x.distance_of_UAV()
    sum += self.Weight*self.number_of_used_UAVs()
    return sum

  def candidate_cost(self):
    sum=0
    for x in self.candidate:
      sum=sum+x.distance_of_UAV()
    sum += self.Weight*self.number_of_used_UAVs_candidate()
    return sum


  def number_of_used_UAVs(self):
    sum=0
    for x in self.list_of_UAVs:
      if len(x.list_of_tasks) > 0:
        sum +=1
    return sum
  
  def number_of_used_UAVs_candidate(self):
    sum=0
    for x in self.candidate:
      if len(x.list_of_tasks) > 0:
        sum +=1
    return sum
    
  def update_UAVs(self, newSol):
    self.list_of_UAVs=newSol
    self.best_Obj=self.cost()

  def update_best_Obj(self, Obj):
    self.best_Obj=Obj

  def update_candidate(self):
    self.candidate=generate_new_sol(self.list_of_UAVs)
    self.candidate_Obj=self.candidate_cost()


  def plott(self):
    for task in self.list_of_tasks:
      plt.plot(task.position.x,task.position.y, marker="o", markersize=20, markerfacecolor="green")
    for uav in self.list_of_UAVs:
      Xs=[uav.position.x]
      Ys=[uav.position.y]
      for t in uav.list_of_tasks:
        Xs.append(t.position.x)
        Ys.append(t.position.y)
      plt.plot(uav.position.x,uav.position.y, marker="o", markersize=20, markerfacecolor="yellow")
      plt.plot(Xs,Ys)
    plt.show()



# # assign random tasks for random UAVs
# def assign_tasks(list_of_tasks, list_of_UAVs):
#   # Choose random task and assign to random UAV
#   # Shallow copy tasks list to remove chosen task from copied list 
#   tasks = copy.copy(list_of_tasks)
  
#   while len(tasks) > 0:
#     task_idx = random.randint(0,len(tasks)-1)
#     task = tasks.pop(task_idx)
#     uav_idx = random.randint(0,len(list_of_UAVs)-1)
#     uav = list_of_UAVs[uav_idx] 
#     n=uav.number_of_assigned_tasks()
#     if uav.number_of_assigned_tasks() < uav.max_tasks:
#       list_of_UAVs[uav_idx].list_of_tasks.append(task)
#     else:
#       continue

def assign_tasks(list_of_tasks,list_of_UAVs):
  tasks=copy.copy(list_of_tasks)
  while len(tasks)>0:
    task_idx=random.randint(0,len(tasks)-1)
    task=tasks.pop(task_idx)
    while True:
      uav_idx=random.randint(0,len(list_of_UAVs)-1)
      list_of_UAVs[uav_idx].list_of_tasks.append(task)
      if isFeasible(list_of_UAVs):
        break

def generate_new_sol(list_of_UAVs):
  UAVs=copy.deepcopy(list_of_UAVs)
  while True:
    uav_idx = random.randint(0,len(UAVs)-1)
    uav = UAVs[uav_idx] 
    if uav.number_of_assigned_tasks() > 0:
      break
  task_idx = 0 if len(uav.list_of_tasks)==0 else random.randint(0,len(uav.list_of_tasks)-1)
  task=uav.list_of_tasks.pop(task_idx)
  while True:
    new_uav_idx = random.randint(0,len(UAVs)-1)
    new_uav = UAVs[new_uav_idx]
    new_task_idx = 0 if len(new_uav.list_of_tasks)==0 else random.randint(0,len(new_uav.list_of_tasks)-1)
    new_uav.list_of_tasks.insert(new_task_idx,task)
    if isFeasible(UAVs):
      break
  
  
  return UAVs
    


def isFeasible(list_of_UAVs):
  for uav in list_of_UAVs:
    if uav.number_of_assigned_tasks()>uav.max_tasks:
      return False
  return True

def initiate_problem(Nuavs,Ntasks,Xmap,Ymap):
  Uavs=[]
  Tasks=[]
  for i in range(Nuavs):
    p=Point(random.randint(0,Xmap),random.randint(0,Ymap))
    Uavs.append(UAV(p,[]))
  for i in range(Ntasks):
    p=Point(random.randint(0,Xmap),random.randint(0,Ymap))
    Tasks.append(Task(p))
  return Uavs,Tasks

def simulated_annealing_David(sys, T0, Tf, beta  ):
  
  i=1  
  T=T0 - beta*i
  while T >= Tf:
    sys.update_candidate()
    diff=sys.candidate_Obj - sys.best_Obj
    if diff < 0 :
      sys.update_UAVs(copy.deepcopy(sys.candidate))
    else:
      metropolis = math.exp(-diff / T)
      if metropolis > random.random():
        sys.update_UAVs(copy.deepcopy(sys.candidate))
    print(sys.best_Obj)
    i+=1  
    T=T0 - beta*i

t1 = Task(Point(2,4))
t2 = Task(Point(1,3))
t3 = Task(Point(3,2))
tasks = [t1,t2,t3]

u1 = UAV(Point(5,2), [])
u2 = UAV(Point(1,1), [])
u3 = UAV(Point(4,3), [])
uavs = [u1,u2,u3]
sys=System(uavs,tasks)
print(sys.best_Obj)
print(sys.candidate_Obj)
sys.plott()

print(sys.best_Obj)
simulated_annealing_David(sys,1500,1,.5)
print(sys.best_Obj)
sys.plott()

result=initiate_problem(10,15,100,100)
sys1=System(result[0],result[1])
sys1.plott()



print(sys1.best_Obj)
simulated_annealing_David(sys1,1500,1,.5)
print(sys1.best_Obj)
# sys.plott()

# hadi
def temperature_geo_update(T0, idx, alpha):
    return T0 * (alpha ** idx)

def temperature_linear_update(T0, idx, beta):
  return T0 - beta * idx

def objective(uavs, sys):
  path_lengths = 0
  for uav in uavs:
    path_lengths = path_lengths + uav.path_length()
  return path_lengths + sys.Weight * sys.number_of_used_UAVs()

# Still not finalised, progress on going
# -Hadi

def simulated_annealing_Hadi(sys, x_map, y_map, T0, Tf, i_max, step_size, temp):
  
  # paramaters
  shift_x, shift_y = 0.1, 0.1
  alpha = 0.7
  beta = (Tf-T0)/i_max
  no_path_points = 1


  # generate initial positions
  uavs = sys.list_of_UAVs
  
  # Assign random tasks to the UAVs
  assign_tasks(sys.list_of_tasks, sys.list_of_UAVs)

  # generate random middle points in the path of the UAV between itself and its tasks
  for uav in uavs:
    uav.position = rand_position(x_map, y_map) # initial position
    for task in uav.list_of_tasks: # initial path
      for i in range(no_path_points):
        uav.path.append(rand_position(x_map, y_map))
      uav.path.append(task.position)

	# evaluate the initial configuration
  # best_eval = sys.cost()
  best_eval = objective(uavs, sys)
 
  # current working solution
  curr, curr_eval = uavs, best_eval
  
  ##################
  # run the algorithm of i_max iterations
  for i in range(i_max):
    # make position shifts
    for uav in uavs:
      for position in uav.path:
        position.shift(shift_x, shift_y)
    
    # evaluate step
    # new_eval = sys.cost()
    new_eval = objective(uavs, sys)

    # check for new best solution
    if new_eval < best_eval:
      # store new best sys
      best, best_eval = sys, new_eval
      # report progress
      print('>%d f(%s) = %.5f' % (i, best, best_eval))


    # difference between candidate and current point evaluation
    diff = new_eval - curr_eval

    # transition probability
    metropolis = math.exp(-diff / t)
    
    # Accept better solution or worse solution if metropolis < p_random
    if diff < 0 or random.random() < metropolis:
      # store the new current point
      curr, curr_eval = sys, new_eval
    # Else, leave as is


    # Update temperature
    # t = temp / float(i + 1)
    t = temperature_linear_update(T0, i+1, beta)
    # t = temperature_geo_update(T0, i+1, alpha)

    if t <= Tf:
      break
    
  return [best, best_eval]



